package com.bmtech.fsql.expression;

import java.util.List;

import com.bmtech.fsql.expression.ast.CompondCondtionNode;
import com.bmtech.fsql.expression.ast.ConditionNode;
import com.bmtech.fsql.expression.ast.ItemConditionNode;

/**
 * Interpreter directly evaluates the abstract syntax tree generated by the
 * Parser. It checks the semantics as it process the tree.
 *
 */
public class FsqlInterpreter {
	public static final String[] NOPARA = new String[0];
	final String sql;
	final List<ItemConditionNode> var;
	public final ConditionNode head;
	public final String[] paras;
	public final int limit[] = new int[] { -1, -1 };
	public final List<OrderInfo> orders;

	public FsqlInterpreter(String sql) throws Exception {
		this(sql, NOPARA);
	}

	public FsqlInterpreter(String sql, List<String> paras) throws Exception {
		this(sql, paras == null || paras.size() == 0 ? NOPARA : toArray(paras));
	}

	private static String[] toArray(List<String> paras2) {
		String[] arr = new String[paras2.size()];
		paras2.toArray(arr);
		return arr;
	}

	public FsqlInterpreter(String sql, String[] paras) throws Exception {
		this.sql = sql;
		Lexer lexer = new Lexer(sql);
		Parser parser = new Parser(lexer);
		parser.program();
		head = parser.conds;
		var = parser.getVar();
		limit[0] = parser.getResultOffset();
		limit[1] = parser.getResultLimit();
		this.paras = paras;

		orders = parser.getOrders();
		if (this.orders.size() == 0) {
			// throw new Exception("no orders set!");
		}

	}

	public ConditionNode toConditionLink() throws Exception {
		int x = 0;
		for (; x < var.size(); x++) {
			var.get(x).setValue(paras[x]);
		}
		// try {
		// if (limit[0] == -1) {
		// limit[0] = Integer.parseInt(paras[x++]);
		// }
		//
		// if (limit[1] == -1) {
		// limit[1] = Integer.parseInt(paras[x++]);
		// }
		// } catch (Exception e) {
		// System.err.println("limit not set properly: " + e);
		// }
		// if (limit[0] < 0) {
		// throw new Exception("limit not set properly: offset = " + limit[0]);
		// }
		//
		// if (limit[1] < 0) {
		// throw new Exception("limit not set properly: limit = " + limit[1]);
		// }

		// if (x != paras.length) {
		// throw new Exception(
		// "expect " + x + " paras, but real paras=" + Arrays.asList(paras) + ",
		// size " + paras.length);
		// }
		return head;
	}

	private static String doSimpleNode(ItemConditionNode node) {
		String queryName = node.getStandardFieldName();
		TokenType tokenType = node.getRelation().type;
		String queryValue = node.getFieldValue();

		return queryName + " " + tokenType + " " + queryValue;
	}

	public static String colletQuery(ConditionNode headNode) throws Exception {
		String ret = "";
		ConditionNode nodeToMake = headNode;
		while (nodeToMake != null) {
			String sub;
			if (nodeToMake.isCompond()) {
				ConditionNode nodeToMake2 = ((CompondCondtionNode) nodeToMake).thisCond;

				ret = colletQuery(nodeToMake2);
				sub = " (" + ret + ")";
			} else {
				sub = doSimpleNode((ItemConditionNode) nodeToMake);
			}

			ret = ret + " " + nodeToMake.getConjunctType() + " " + sub;
			nodeToMake = nodeToMake.nextCondition;
		}
		return ret;
	}

	public static void main(String[] args) throws Exception {
		FsqlInterpreter ipt = new FsqlInterpreter("a > 'zzza' and c > 24.19 && (x>'zzzzx' && y like 'dfa')");
		ConditionNode cond = ipt.toConditionLink();
		System.out.println(colletQuery(cond));
	}

}
